# https://github.com/Jan-Aarela/Fibonacci-y86
# https://boginw.github.io/js-y86-64/

.pos 0
    irmovq array,%r11
    irmovq $233,%r12
    rmmovq %r12,(%r11)
    irmovq $987,%r12
    rmmovq %r12,8(%r11)
    irmovq $1597,%r12        # Example input numbers to be determided if fibonacci.
    rmmovq %r12,16(%r11)
    irmovq $1590,%r12
    rmmovq %r12,24(%r11)
    irmovq $0,%r12
    rmmovq %r12,32(%r11)


main:
    irmovq stack, %rsp      # Initializes stack.
    jmp start   

# Gets the next value from array and starts checking the number.
start:
    mrmovq (%r11), %rcx     # Takes value from memory address.
    andq %rcx, %rcx
    je end                  # If number = 0, quits the program.
    call process            # If number > 0, proceeds to the checker.
 
    irmovq $8, %rbx         # Array "offsetter".
    addq %rbx, %r11         # Offsets memory address in array by 8.
    jmp start               # Returns to init to check next value in array.


# Starts processing the number.
# Using formula 5*x^2+-4 == (int sqrt(5*x^2+-4))^2.
process:
    rrmovq %rcx, %r8        # Sets multiplicant & multiplier (%r8 & %r9)
    rrmovq %rcx, %r9
    call multiplier         # Calculates square.

    rrmovq %r10, %r8
    irmovq $5, %r9
    call multiplier         # Multiplies square by 5.

    irmovq $4, %r14         # 4 additor.
    addq %r14, %r10         
    call squareroot         # Calculates root(square + 4).
    
    rrmovq %r8, %r12        # Saves 
    rrmovq %rsi, %r8
    rrmovq %rsi, %r9
    call multiplier         # Calculates square.

    subq %r12, %r10
    je isfibonacci          # If perfect square (+4), return to init.

    rrmovq %r12, %r8        
    rrmovq %r8, %r10
    irmovq $8, %r14         # 8  subtractor.
    subq %r14, %r10         
    call squareroot         # Calculates root(square - 4).

    rrmovq %r8, %r12        
    rrmovq %rsi, %r8
    rrmovq %rsi, %r9
    call multiplier         # Calculates square.

    subq %r12, %r10
    je isfibonacci          # If perfect square (-4), return to init.

    jmp notfibonacci        # If conditions are not met, number is not a fibonacci.
    
    isfibonacci:
        ret                 # Returns back start.


# Calcualates value with peasant multiplication. 
multiplier:
    irmovq $0, %r10         # Output
    irmovq $1, %rsi         # Bit checker
    irmovq $1, %rdi         # Multiplier
    
    irmovq $12, %rbx        # Non ideal string lenght.
    irmovq $1, %rdx         # Subract from %rbx 
    
    addition:
        andq %r9, %rsi      # Checks multiplier's boolean value.
        je shift            # If equals 0, skips additon.
        addq %r8, %r10      # Adds n * %r8 to %r10. 
        
        jmp shift           
        
    shift:
        addq %rdi, %rdi     # Doubles the multiplier, effectivly making a bitshift.
        rrmovq %rdi, %rsi
        addq %r8, %r8       # Doubles the 
        
        subq %rdx, %rbx     # Reduces remaining multiplication count by 1.
        je endmul           # If count is 0, multiplication ends
        
        jmp addition        # If count > 0, continues multiplication 
    
    endmul:
        ret                 # Returns back to process.

    
# Calculates root by calculating squared root and comparing it to original value. 
# Using formula root^2 = multiplier * (prev. root + cur. root) + prev.square.
squareroot:
    irmovq $1, %rsi         # Root.
    rrmovq %r10, %r8        # Comparsion value.
    irmovq $1, %r9          # Current squared root.
    irmovq $0, %rdx         # Previous squared root. 
    irmovq $0, %rdi         # Previous root.
    irmovq $1, %r12         # Multiplier.
    irmovq $1, %r13         # Addtiton / subtraction constant.
    irmovq $0, %r14         # Copy of exponent.
    irmovq $1, %rcx         # Exponent.
    
    checker:
        rrmovq %r9, %r10
        subq %r8, %r9
        je endroot          # If squared root = comparison value, quits root function.
        jl rootup           # If squared root < comparison value, starts increasing exponent. 
        
        subq %r13, %r12
        subq %r13, %r12
        je rounding         # If sqaured root > comparison value multiplier = 0, rounds root.
        jg halfroot         # If squared root > comparison value, starts reducing exponent.
        
    rootup:
        rrmovq %rsi, %rdi   # Saves previous root.
        rrmovq %r10, %rdx   # Saves previous squared root.
        
        addq %r12, %rsi     # increases the root value.
        
        rrmovq %rdi, %r10
        addq %rsi, %r10     # Combines previous and current root values together.
        
        rrmovq %rcx, %r14
        call exponentiation # 2^(r14) * (r10) 
        
        addq %rdx, %r10
        rrmovq %r10, %r9    # Sets current squared root value.
        
        addq %r12, %r12     # Doubles multiplier.
        
        jmp checker         
        
    exponentiation:
        subq %r13, %r14     # Checks exponents value. If after subraction 0, skips.
        je exitexpo
        addq %r10, %r10     # Doubles the value.
        
        jmp exponentiation
    
    exitexpo:
        addq %r13, %rcx     # Increases exponent value by 1.
        ret
    
    halfroot:
        rrmovq %rdi, %rsi   # Sets the previous root value to current.
        rrmovq %rdx, %r9    # Sets the previous squared value to current.
        irmovq $1, %r12     # Resets multiplier value.
        irmovq $1, %r14     # Resets multiplier value.
        irmovq $1, %rcx     # Resets exponent value.
        
        jmp checker
    
    rounding:
        irmovq $1, %r12     # Subtracs 1 from root.
        subq %r12, %rsi
        
        jmp endroot    
    
    endroot: 
        ret


# Moves value from an array if the number is not a fibonacci number.
notfibonacci: 
    mrmovq (%r11), %rax     # Moves non-finonacci number into %rax.
    jmp end                 # And ultimately quits the code.

    
# Quitting.    
end:
    halt


.pos 0x300
stack:
    
.pos 0x700
array:
